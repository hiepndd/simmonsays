// Code generated by protoc-gen-go. DO NOT EDIT.
// source: simonsays.proto

package symonsayspb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Color int32

const (
	Color_UNSPECIFIED Color = 0
	Color_RED         Color = 1
	Color_GREEN       Color = 2
	Color_YELLOW      Color = 3
	Color_BLUE        Color = 4
)

var Color_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "RED",
	2: "GREEN",
	3: "YELLOW",
	4: "BLUE",
}

var Color_value = map[string]int32{
	"UNSPECIFIED": 0,
	"RED":         1,
	"GREEN":       2,
	"YELLOW":      3,
	"BLUE":        4,
}

func (x Color) String() string {
	return proto.EnumName(Color_name, int32(x))
}

func (Color) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5c554a713a542d07, []int{0}
}

type Response_State int32

const (
	Response_UNSPECIFIED Response_State = 0
	Response_BEGIN       Response_State = 1
	Response_START_TURN  Response_State = 2
	Response_STOP_TURN   Response_State = 3
	Response_WIN         Response_State = 4
	Response_LOSE        Response_State = 5
)

var Response_State_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "BEGIN",
	2: "START_TURN",
	3: "STOP_TURN",
	4: "WIN",
	5: "LOSE",
}

var Response_State_value = map[string]int32{
	"UNSPECIFIED": 0,
	"BEGIN":       1,
	"START_TURN":  2,
	"STOP_TURN":   3,
	"WIN":         4,
	"LOSE":        5,
}

func (x Response_State) String() string {
	return proto.EnumName(Response_State_name, int32(x))
}

func (Response_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5c554a713a542d07, []int{1, 0}
}

type Request struct {
	// Types that are valid to be assigned to Event:
	//	*Request_Join
	//	*Request_Press
	Event                isRequest_Event `protobuf_oneof:"event"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_5c554a713a542d07, []int{0}
}

func (m *Request) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Request.Unmarshal(m, b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Request.Marshal(b, m, deterministic)
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return xxx_messageInfo_Request.Size(m)
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

type isRequest_Event interface {
	isRequest_Event()
}

type Request_Join struct {
	Join *Request_Player `protobuf:"bytes,1,opt,name=join,proto3,oneof"`
}

type Request_Press struct {
	Press Color `protobuf:"varint,2,opt,name=press,proto3,enum=simonsays.Color,oneof"`
}

func (*Request_Join) isRequest_Event() {}

func (*Request_Press) isRequest_Event() {}

func (m *Request) GetEvent() isRequest_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *Request) GetJoin() *Request_Player {
	if x, ok := m.GetEvent().(*Request_Join); ok {
		return x.Join
	}
	return nil
}

func (m *Request) GetPress() Color {
	if x, ok := m.GetEvent().(*Request_Press); ok {
		return x.Press
	}
	return Color_UNSPECIFIED
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Request) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Request_Join)(nil),
		(*Request_Press)(nil),
	}
}

//A Player of the Simon says game.
type Request_Player struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request_Player) Reset()         { *m = Request_Player{} }
func (m *Request_Player) String() string { return proto.CompactTextString(m) }
func (*Request_Player) ProtoMessage()    {}
func (*Request_Player) Descriptor() ([]byte, []int) {
	return fileDescriptor_5c554a713a542d07, []int{0, 0}
}

func (m *Request_Player) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Request_Player.Unmarshal(m, b)
}
func (m *Request_Player) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Request_Player.Marshal(b, m, deterministic)
}
func (m *Request_Player) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request_Player.Merge(m, src)
}
func (m *Request_Player) XXX_Size() int {
	return xxx_messageInfo_Request_Player.Size(m)
}
func (m *Request_Player) XXX_DiscardUnknown() {
	xxx_messageInfo_Request_Player.DiscardUnknown(m)
}

var xxx_messageInfo_Request_Player proto.InternalMessageInfo

func (m *Request_Player) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type Response struct {
	// Types that are valid to be assigned to Event:
	//	*Response_Turn
	//	*Response_LightUp
	Event                isResponse_Event `protobuf_oneof:"event"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_5c554a713a542d07, []int{1}
}

func (m *Response) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Response.Unmarshal(m, b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Response.Marshal(b, m, deterministic)
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return xxx_messageInfo_Response.Size(m)
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

type isResponse_Event interface {
	isResponse_Event()
}

type Response_Turn struct {
	Turn Response_State `protobuf:"varint,1,opt,name=turn,proto3,enum=simonsays.Response_State,oneof"`
}

type Response_LightUp struct {
	LightUp Color `protobuf:"varint,2,opt,name=light_up,json=lightUp,proto3,enum=simonsays.Color,oneof"`
}

func (*Response_Turn) isResponse_Event() {}

func (*Response_LightUp) isResponse_Event() {}

func (m *Response) GetEvent() isResponse_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *Response) GetTurn() Response_State {
	if x, ok := m.GetEvent().(*Response_Turn); ok {
		return x.Turn
	}
	return Response_UNSPECIFIED
}

func (m *Response) GetLightUp() Color {
	if x, ok := m.GetEvent().(*Response_LightUp); ok {
		return x.LightUp
	}
	return Color_UNSPECIFIED
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Response) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Response_Turn)(nil),
		(*Response_LightUp)(nil),
	}
}

func init() {
	proto.RegisterEnum("simonsays.Color", Color_name, Color_value)
	proto.RegisterEnum("simonsays.Response_State", Response_State_name, Response_State_value)
	proto.RegisterType((*Request)(nil), "simonsays.Request")
	proto.RegisterType((*Request_Player)(nil), "simonsays.Request.Player")
	proto.RegisterType((*Response)(nil), "simonsays.Response")
}

func init() { proto.RegisterFile("simonsays.proto", fileDescriptor_5c554a713a542d07) }

var fileDescriptor_5c554a713a542d07 = []byte{
	// 357 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x91, 0xdd, 0x8e, 0x9a, 0x40,
	0x14, 0xc7, 0x1d, 0x3e, 0x44, 0x8e, 0x11, 0x27, 0xd3, 0x1b, 0xeb, 0x95, 0xe1, 0x8a, 0x34, 0x29,
	0x6d, 0x6c, 0xfa, 0x00, 0x45, 0xa7, 0x96, 0x84, 0xa0, 0x19, 0x20, 0xa6, 0xbd, 0x31, 0x18, 0x27,
	0x2d, 0x8d, 0x02, 0xcb, 0xe0, 0x26, 0x3c, 0xc1, 0xbe, 0xdb, 0x3e, 0xd5, 0x66, 0xc0, 0xb8, 0x9b,
	0x75, 0xb3, 0x97, 0x33, 0xf3, 0xfb, 0x7f, 0x9c, 0x39, 0x30, 0x16, 0xd9, 0xa9, 0xc8, 0x45, 0xda,
	0x08, 0xb7, 0xac, 0x8a, 0xba, 0x20, 0xe6, 0xf5, 0xc2, 0x7e, 0x40, 0x60, 0x30, 0x7e, 0x77, 0xe6,
	0xa2, 0x26, 0x5f, 0x40, 0xfb, 0x5f, 0x64, 0xf9, 0x04, 0xcd, 0x90, 0x33, 0x9c, 0x7f, 0x74, 0x9f,
	0x65, 0x17, 0xc2, 0xdd, 0x1c, 0xd3, 0x86, 0x57, 0xbf, 0x7a, 0xac, 0x05, 0x89, 0x03, 0x7a, 0x59,
	0x71, 0x21, 0x26, 0xca, 0x0c, 0x39, 0xd6, 0x1c, 0xbf, 0x50, 0x2c, 0x8a, 0x63, 0x21, 0xc1, 0x0e,
	0x98, 0x4e, 0xa0, 0xdf, 0x69, 0x89, 0x05, 0x4a, 0x76, 0x68, 0x23, 0x4c, 0xa6, 0x64, 0x07, 0xcf,
	0x00, 0x9d, 0xdf, 0xf3, 0xbc, 0xb6, 0x1f, 0x11, 0x0c, 0x18, 0x17, 0x65, 0x91, 0x0b, 0x2e, 0xab,
	0xd4, 0xe7, 0xaa, 0xab, 0x62, 0xbd, 0xaa, 0xd2, 0x21, 0x6e, 0x54, 0xa7, 0x35, 0x97, 0x55, 0x24,
	0x48, 0x3e, 0xc3, 0xe0, 0x98, 0xfd, 0xfd, 0x57, 0xef, 0xce, 0xe5, 0x3b, 0x6d, 0x8c, 0x96, 0x49,
	0x4a, 0x3b, 0x01, 0xbd, 0xd5, 0x93, 0x31, 0x0c, 0x93, 0x30, 0xda, 0xd0, 0x85, 0xff, 0xd3, 0xa7,
	0x4b, 0xdc, 0x23, 0x26, 0xe8, 0x1e, 0x5d, 0xf9, 0x21, 0x46, 0xc4, 0x02, 0x88, 0xe2, 0x1f, 0x2c,
	0xde, 0xc5, 0x09, 0x0b, 0xb1, 0x42, 0x46, 0x60, 0x46, 0xf1, 0x7a, 0xd3, 0x1d, 0x55, 0x62, 0x80,
	0xba, 0xf5, 0x43, 0xac, 0x91, 0x01, 0x68, 0xc1, 0x3a, 0xa2, 0x58, 0xbf, 0x0e, 0xf3, 0xc9, 0x03,
	0xbd, 0xcd, 0xbc, 0xf5, 0x37, 0x40, 0x65, 0x74, 0x89, 0x91, 0x0c, 0x5a, 0x31, 0x4a, 0xa5, 0x31,
	0x40, 0xff, 0x37, 0x0d, 0x82, 0xf5, 0x16, 0xab, 0xd2, 0xcc, 0x0b, 0x12, 0x8a, 0xb5, 0xb9, 0x07,
	0x66, 0x24, 0x27, 0x88, 0xd2, 0x46, 0x90, 0xef, 0xa0, 0xad, 0xd2, 0x13, 0x27, 0xe4, 0x76, 0x2b,
	0xd3, 0x0f, 0x6f, 0x7c, 0x8f, 0xdd, 0x73, 0xd0, 0x57, 0xe4, 0x8d, 0xfe, 0x0c, 0x45, 0x73, 0x79,
	0x2b, 0xf7, 0xfb, 0x7e, 0xbb, 0xff, 0x6f, 0x4f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x99, 0xa9, 0x17,
	0x34, 0x12, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SimonSaysClient is the client API for SimonSays service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SimonSaysClient interface {
	//
	//Game process is the following:
	//
	//A Join Request should be sent to the game. This tells it
	//to join a game (or start a new one if one isn't already waiting on a game).
	//
	//The Response stream will send through a BEGIN Response.State to let you know that
	//the Game has been started.
	//
	//When the player receives a START_TURN response, the server can take your input for the turn.
	//
	//When the player receives a STOP_TURN response, the serer is no longer taking input for the turn.
	//
	//A WIN state says you won the game. A LOSE state means that you got an input wrong, and have lost.
	//
	//To send input, send a Request with an event type of Color.
	//
	//When you receive a Response of type Color, then light up that colour.
	Game(ctx context.Context, opts ...grpc.CallOption) (SimonSays_GameClient, error)
}

type simonSaysClient struct {
	cc *grpc.ClientConn
}

func NewSimonSaysClient(cc *grpc.ClientConn) SimonSaysClient {
	return &simonSaysClient{cc}
}

func (c *simonSaysClient) Game(ctx context.Context, opts ...grpc.CallOption) (SimonSays_GameClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SimonSays_serviceDesc.Streams[0], "/simonsays.SimonSays/Game", opts...)
	if err != nil {
		return nil, err
	}
	x := &simonSaysGameClient{stream}
	return x, nil
}

type SimonSays_GameClient interface {
	Send(*Request) error
	Recv() (*Response, error)
	grpc.ClientStream
}

type simonSaysGameClient struct {
	grpc.ClientStream
}

func (x *simonSaysGameClient) Send(m *Request) error {
	return x.ClientStream.SendMsg(m)
}

func (x *simonSaysGameClient) Recv() (*Response, error) {
	m := new(Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SimonSaysServer is the server API for SimonSays service.
type SimonSaysServer interface {
	//
	//Game process is the following:
	//
	//A Join Request should be sent to the game. This tells it
	//to join a game (or start a new one if one isn't already waiting on a game).
	//
	//The Response stream will send through a BEGIN Response.State to let you know that
	//the Game has been started.
	//
	//When the player receives a START_TURN response, the server can take your input for the turn.
	//
	//When the player receives a STOP_TURN response, the serer is no longer taking input for the turn.
	//
	//A WIN state says you won the game. A LOSE state means that you got an input wrong, and have lost.
	//
	//To send input, send a Request with an event type of Color.
	//
	//When you receive a Response of type Color, then light up that colour.
	Game(SimonSays_GameServer) error
}

// UnimplementedSimonSaysServer can be embedded to have forward compatible implementations.
type UnimplementedSimonSaysServer struct {
}

func (*UnimplementedSimonSaysServer) Game(srv SimonSays_GameServer) error {
	return status.Errorf(codes.Unimplemented, "method Game not implemented")
}

func RegisterSimonSaysServer(s *grpc.Server, srv SimonSaysServer) {
	s.RegisterService(&_SimonSays_serviceDesc, srv)
}

func _SimonSays_Game_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SimonSaysServer).Game(&simonSaysGameServer{stream})
}

type SimonSays_GameServer interface {
	Send(*Response) error
	Recv() (*Request, error)
	grpc.ServerStream
}

type simonSaysGameServer struct {
	grpc.ServerStream
}

func (x *simonSaysGameServer) Send(m *Response) error {
	return x.ServerStream.SendMsg(m)
}

func (x *simonSaysGameServer) Recv() (*Request, error) {
	m := new(Request)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SimonSays_serviceDesc = grpc.ServiceDesc{
	ServiceName: "simonsays.SimonSays",
	HandlerType: (*SimonSaysServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Game",
			Handler:       _SimonSays_Game_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "simonsays.proto",
}
